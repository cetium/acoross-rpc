/*
*
* Copyright 2015-2016, Google Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are
* met:
*
*     * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above
* copyright notice, this list of conditions and the following disclaimer
* in the documentation and/or other materials provided with the
* distribution.
*     * Neither the name of Google Inc. nor the names of its
* contributors may be used to endorse or promote products derived from
* this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/

#include <map>

#include "acoross_generator.h"
#include "src/compiler/cpp_generator_helpers.h"

#include "src/compiler/config.h"

#include <sstream>

namespace acoross_rpc_cpp_generator {
namespace {

template <class T>
grpc::string as_string(T x)
{
	std::ostringstream out;
	out << x;
	return out.str();
}

bool NoStreaming(const grpc::protobuf::MethodDescriptor *method)
{
	return !method->client_streaming() && !method->server_streaming();
}

bool ClientOnlyStreaming(const grpc::protobuf::MethodDescriptor *method)
{
	return method->client_streaming() && !method->server_streaming();
}

bool ServerOnlyStreaming(const grpc::protobuf::MethodDescriptor *method)
{
	return !method->client_streaming() && method->server_streaming();
}

bool BidiStreaming(const grpc::protobuf::MethodDescriptor *method)
{
	return method->client_streaming() && method->server_streaming();
}

grpc::string FilenameIdentifier(const grpc::string &filename)
{
	grpc::string result;
	for (unsigned i = 0; i < filename.size(); i++)
	{
		char c = filename[i];
		if (isalnum(c))
		{
			result.push_back(c);
		}
		else
		{
			static char hex[] = "0123456789abcdef";
			result.push_back('_');
			result.push_back(hex[(c >> 4) & 0xf]);
			result.push_back(hex[c & 0xf]);
		}
	}
	return result;
}
}  // namespace

   //acoross changed
grpc::string GetHeaderPrologue(const grpc::protobuf::FileDescriptor *file,
	const Parameters &params)
{
	grpc::string output;
	{
		// Scope the output stream so it closes and finalizes output to the string.
		grpc::protobuf::io::StringOutputStream output_stream(&output);
		grpc::protobuf::io::Printer printer(&output_stream, '$');
		std::map<grpc::string, grpc::string> vars;

		vars["filename"] = file->name();
		vars["filename_identifier"] = FilenameIdentifier(file->name());
		vars["filename_base"] = grpc_generator::StripProto(file->name());

		printer.Print(vars, "// Generated by the acoross-rpc protobuf plugin.\n");
		printer.Print(vars,
			"// If you make any local change, they will be lost.\n");
		printer.Print(vars, "// source: $filename$\n");
		printer.Print(vars, "#ifndef ACOROSS_RPC_$filename_identifier$__INCLUDED\n");
		printer.Print(vars, "#define ACOROSS_RPC_$filename_identifier$__INCLUDED\n");
		printer.Print(vars, "\n");
		printer.Print(vars, "#include \"$filename_base$.pb.h\"\n");
		printer.Print(vars, "\n");
	}
	return output;
}

//acoross changed
grpc::string GetHeaderIncludes(const grpc::protobuf::FileDescriptor *file,
	const Parameters &params)
{
	grpc::string temp =
		"#include <SDKDDKVer.h>\n"
		"#include <boost/asio.hpp>\n"
		"#include <acoross/rpc/rpc_service.h>\n"
		"#include <acoross/rpc/rpc_stub.h>\n"
		"#include <acoross/rpc/rpc_macros.h>\n"
		"\n";

	if (!file->package().empty())
	{
		std::vector<grpc::string> parts =
			grpc_generator::tokenize(file->package(), ".");

		for (auto part = parts.begin(); part != parts.end(); part++)
		{
			temp.append("namespace ");
			temp.append(*part);
			temp.append(" {\n");
		}
		temp.append("\n");
	}

	return temp;
}

void PrintHeaderService(grpc::protobuf::io::Printer *printer,
	const grpc::protobuf::ServiceDescriptor *service,
	std::map<grpc::string, grpc::string> *vars)
{
	(*vars)["Service"] = service->name();

	printer->Print(*vars,
		"class $Service$ final {\n"
		" public:\n");
	printer->Indent();

	// enum
	printer->Print("enum Protocol\n{\n");
	printer->Indent();
	for (int i = 0; i < service->method_count(); ++i)
	{
		printer->Print(service->method(i)->name().c_str());
		printer->Print(",\n");
	}
	printer->Outdent();
	printer->Print("};\n\n");

	// Server side
	printer->Print(
		"class Service : public ::acoross::rpc::RpcService \n"
		"{\n"
		"public:\n");
	printer->Indent();
	printer->Print("Service(::boost::asio::io_service& io_service, ::boost::asio::ip::tcp::socket&& socket);\n");
	printer->Print("virtual ~Service() {}\n");  //TODO: doing here!!
	printer->Print("\n");
	printer->Outdent();
	printer->Print("private:\n");
	printer->Indent();
	for (int i = 0; i < service->method_count(); ++i)
	{
		(*vars)["Method"] = service->method(i)->name();
		(*vars)["Request"] =
			grpc_cpp_generator::ClassName(service->method(i)->input_type(), true);
		(*vars)["Response"] =
			grpc_cpp_generator::ClassName(service->method(i)->output_type(), true);

		printer->Print(*vars, "DEF_SERVICE($Method$, $Request$, $Response$)\n");
	}
	printer->Print("\n");
	printer->Outdent();
	printer->Print("};\n\n");

	// Client side
	printer->Print(
		"class Stub : public ::acoross::rpc::RpcStub\n"
		"{\n"
		"public:\n");
	printer->Indent();
	printer->Print("Stub(::boost::asio::io_service& io_service, ::boost::asio::ip::tcp::socket&& socket);\n");
	printer->Print("virtual ~Stub() {}\n");
	for (int i = 0; i < service->method_count(); ++i)
	{
		(*vars)["Method"] = service->method(i)->name();
		(*vars)["Request"] =
			grpc_cpp_generator::ClassName(service->method(i)->input_type(), true);
		(*vars)["Response"] =
			grpc_cpp_generator::ClassName(service->method(i)->output_type(), true);
		printer->Print(*vars, "DEF_STUB($Method$, $Request$, $Response$)\n");
	}
	printer->Outdent();
	printer->Print("};\n\n");

	printer->Outdent();
	printer->Print("};\n\n");
}

grpc::string GetHeaderServices(const grpc::protobuf::FileDescriptor *file,
	const Parameters &params)
{
	grpc::string output;
	{
		// Scope the output stream so it closes and finalizes output to the string.
		grpc::protobuf::io::StringOutputStream output_stream(&output);
		grpc::protobuf::io::Printer printer(&output_stream, '$');
		std::map<grpc::string, grpc::string> vars;
		// Package string is empty or ends with a dot. It is used to fully qualify
		// method names.
		vars["Package"] = file->package();
		if (!file->package().empty())
		{
			vars["Package"].append(".");
		}

		if (!params.services_namespace.empty())
		{
			vars["services_namespace"] = params.services_namespace;
			printer.Print(vars, "\nnamespace $services_namespace$ {\n\n");
		}

		for (int i = 0; i < file->service_count(); ++i)
		{
			PrintHeaderService(&printer, file->service(i), &vars);
			printer.Print("\n");
		}

		if (!params.services_namespace.empty())
		{
			printer.Print(vars, "}  // namespace $services_namespace$\n\n");
		}
	}
	return output;
}

grpc::string GetHeaderEpilogue(const grpc::protobuf::FileDescriptor *file,
	const Parameters &params)
{
	grpc::string output;
	{
		// Scope the output stream so it closes and finalizes output to the string.
		grpc::protobuf::io::StringOutputStream output_stream(&output);
		grpc::protobuf::io::Printer printer(&output_stream, '$');
		std::map<grpc::string, grpc::string> vars;

		vars["filename"] = file->name();
		vars["filename_identifier"] = FilenameIdentifier(file->name());

		if (!file->package().empty())
		{
			std::vector<grpc::string> parts =
				grpc_generator::tokenize(file->package(), ".");

			for (auto part = parts.rbegin(); part != parts.rend(); part++)
			{
				vars["part"] = *part;
				printer.Print(vars, "}  // namespace $part$\n");
			}
			printer.Print(vars, "\n");
		}

		printer.Print(vars, "\n");
		printer.Print(vars, "#endif  // ACOROSS_RPC_$filename_identifier$__INCLUDED\n");
	}
	return output;
}

//done by acoross
grpc::string GetSourcePrologue(const grpc::protobuf::FileDescriptor *file,
	const Parameters &params)
{
	grpc::string output;
	{
		// Scope the output stream so it closes and finalizes output to the string.
		grpc::protobuf::io::StringOutputStream output_stream(&output);
		grpc::protobuf::io::Printer printer(&output_stream, '$');
		std::map<grpc::string, grpc::string> vars;

		vars["filename"] = file->name();
		vars["filename_base"] = grpc_generator::StripProto(file->name());

		printer.Print(vars, "// Generated by the acoross-rpc protobuf plugin.\n");
		printer.Print(vars,
			"// If you make any local change, they will be lost.\n");
		printer.Print(vars, "// source: $filename$\n\n");
		printer.Print(vars, "#include \"$filename_base$.pb.h\"\n");
		printer.Print(vars, "#include \"$filename_base$.rpc.h\"\n");
		printer.Print(vars, "\n");
	}
	return output;
}

grpc::string GetSourceIncludes(const grpc::protobuf::FileDescriptor *file,
	const Parameters &param)
{
	grpc::string output;
	{
		// Scope the output stream so it closes and finalizes output to the string.
		grpc::protobuf::io::StringOutputStream output_stream(&output);
		grpc::protobuf::io::Printer printer(&output_stream, '$');
		std::map<grpc::string, grpc::string> vars;

		//printer.Print(vars, "#include <grpc++/impl/codegen/sync_stream.h>\n");
		//printer.Print("\n");

		if (!file->package().empty())
		{
			std::vector<grpc::string> parts =
				grpc_generator::tokenize(file->package(), ".");

			for (auto part = parts.begin(); part != parts.end(); part++)
			{
				vars["part"] = *part;
				printer.Print(vars, "namespace $part$ {\n");
			}
		}

		printer.Print(vars, "\n");
	}
	return output;
}

void PrintSourceService(grpc::protobuf::io::Printer *printer,
	const grpc::protobuf::ServiceDescriptor *service,
	std::map<grpc::string, grpc::string> *vars)
{
	(*vars)["Service"] = service->name();

	printer->Print(*vars,
		"$Service$::Service::Service("
		"::boost::asio::io_service& io_service, ::boost::asio::ip::tcp::socket&& socket)\n"
		"\t: ::acoross::rpc::RpcService(io_service, std::move(socket))\n");
	printer->Print("{\n");
	printer->Indent();
	for (int i = 0; i < service->method_count(); ++i)
	{
		const grpc::protobuf::MethodDescriptor *method = service->method(i);
		(*vars)["Method"] = method->name();
		(*vars)["Request"] =
			grpc_cpp_generator::ClassName(method->input_type(), true);
		(*vars)["Response"] =
			grpc_cpp_generator::ClassName(method->output_type(), true);
		printer->Print(*vars, "REGISTER_SERVICE($Method$, $Request$, $Response$)\n");
	}
	printer->Outdent();
	printer->Print("}\n");

	printer->Print("\n");
	printer->Print(*vars,
		"$Service$::Stub::Stub(::boost::asio::io_service& io_service, ::boost::asio::ip::tcp::socket&& socket)\n"
		"\t: ::acoross::rpc::RpcStub(io_service, std::move(socket))\n"
		"{}\n\n");
}

grpc::string GetSourceServices(const grpc::protobuf::FileDescriptor *file,
	const Parameters &params)
{
	grpc::string output;
	{
		// Scope the output stream so it closes and finalizes output to the string.
		grpc::protobuf::io::StringOutputStream output_stream(&output);
		grpc::protobuf::io::Printer printer(&output_stream, '$');
		std::map<grpc::string, grpc::string> vars;
		// Package string is empty or ends with a dot. It is used to fully qualify
		// method names.
		vars["Package"] = file->package();
		if (!file->package().empty())
		{
			vars["Package"].append(".");
		}
		if (!params.services_namespace.empty())
		{
			vars["ns"] = params.services_namespace + "::";
			vars["prefix"] = params.services_namespace;
		}
		else
		{
			vars["ns"] = "";
			vars["prefix"] = "";
		}

		for (int i = 0; i < file->service_count(); ++i)
		{
			PrintSourceService(&printer, file->service(i), &vars);
			printer.Print("\n");
		}
	}
	return output;
}

//done by acoross
grpc::string GetSourceEpilogue(const grpc::protobuf::FileDescriptor *file,
	const Parameters &params)
{
	grpc::string temp;

	if (!file->package().empty())
	{
		std::vector<grpc::string> parts =
			grpc_generator::tokenize(file->package(), ".");

		for (auto part = parts.begin(); part != parts.end(); part++)
		{
			temp.append("}  // namespace ");
			temp.append(*part);
			temp.append("\n");
		}
		temp.append("\n");
	}

	return temp;
}

}  // namespace acoross_rpc_cpp_generator
